**# Heroes Task Solution

Реализация алгоритмов для пошаговой стратегии Heroes.

## 1. Генерация армии противника (GeneratePresetImpl)
**Алгоритм:** Применение жадного подхода.
1. Упорядочиваем доступные типы юнитов по критерию "боевая эффективность", вычисляемому как отношение суммы характеристик атаки и здоровья к стоимости юнита.
2. Последовательно добавляем в армию наиболее эффективные юниты, соблюдая ограничение в 11 экземпляров для каждого типа.
3. Для каждого нового юнита случайным образом определяются свободные координаты размещения в пределах отведенной зоны.

**Вычислительная сложность:** O(T log T + N), где T — количество типов юнитов, N — итоговое число созданных юнитов.
* Сортировка типов: `O(T log T)`.
* Наполнение армии: `O(N)`.

## 2. Пошаговая симуляция сражения (SimulateBattleImpl)
**Алгоритм:** Поочередная обработка ходов.
В рамках каждого раунда живые юниты обеих армий упорядочиваются по убыванию показателя атаки, после чего совершают атаку согласно своей программной логике.

**Вычислительная сложность:** O(R × (U log U + U × P)), где R — количество раундов, U — число живых юнитов, P — сложность поиска пути.
* Сортировка юнитов в раунде: `O(U log U)`.
* Обработка ходов: `O(U)`.

## 3. Определение доступных целей для атаки (SuitableForAttackUnitsFinderImpl)
**Алгоритм:** Анализ построения противника.
Проверяются три ряда вражеской формации. В зависимости от направления атаки (слева или справа) выбирается крайний незащищенный юнит в каждом ряду — имеющий минимальную или максимальную X-координату соответственно.

**Вычислительная сложность:** O(K × M), где K = 3 (количество рядов), M — среднее число юнитов в ряду.
* Проход по всем рядам и их элементам выполняется однократно.
* Сложность линейно зависит от общего количества проверяемых юнитов.

## 4. Поиск оптимального маршрута движения (UnitTargetPathFinderImpl)
**Алгоритм:** Поиск в ширину (BFS) на сетке.
Применяется для нахождения кратчайшего пути в невзвешенном графе, представляющем игровое поле. Занятые клетки учитываются с помощью хэш-таблицы для обеспечения быстрого доступа.

**Вычислительная сложность:** O(W × H), где W = 27 (ширина поля), H = 21 (высота поля).
* В наихудшем сценарии алгоритм исследует каждую клетку игрового поля.
* Проверка занятости клетки выполняется за O(1) благодаря структуре HashSet.
* Финальная сложность пропорциональна общему количеству клеток на игровом поле.**
